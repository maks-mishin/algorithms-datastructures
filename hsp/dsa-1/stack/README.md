Стек -- это простой тип данных, который работает по принципу "последний вошёл -- первый вышел". Стек поддерживает всего две операции -- `push` (втолкнуть) и `pop` (вытолкнуть) и представляет собой линейное хранилище элементов, в котором есть только один вход. Операция `push` помещает элемент в этот вход -- говорят, на самый верх стека. Операция `pop` извлекает последний втолкнутый в стек элемент. Кроме того, стеки обычно поддерживают для удобства операцию `peek()` -- получить верхний элемент стека, но не удалять его.

Говорят ещё, что стек работает по схемам
- LIFO = Last in First out (последний вошёл, первый вышел)
- FILO = First in Last out (первый вошёл, последний вышел)

Например, если мы делаем последовательно push(1), push(2) и push(3) для исходно пустого стека, то вызовы pop() вернут 3, потом 2, и потом 1 Сам стек в итоге снова окажется пустым.

Где востребованы LIFO/FILO? Во множестве самых разных задач, начиная от бэктрекинга/отката (когда например мы храним в стеке операции, выполненные в текстовом редакторе, чтобы их можно было корректно откатывать) до рекурсивного разбора абстрактных синтаксических деревьев.

Реализация стека проста и во многом интуитивно понятна. Мы можем использовать для хранения стека самые разные
структуры данных, обычно уже существующие в языке: как
правило, это динамический список, который расширяется новым элементом простой операцией добавления "в хвост". Мы условимся верхушкой стека считать последний элемент в
списке. Соответственно, операция pop() должна выдавать этот последний элемент, удаляя его из списка.

Пример использования стека:
```python
stack = Stack()
stack.push(1)
stack.push("2")
stack.push(3.14)

while stack.size() > 0:
    stack.pop()
```

Исходная заготовка класса стека выглядит следующим образом:
```python
class Stack:
    def __init__(self):
        self.stack = []
    
    def size(self):
        return len(self.stack)
    
    def pop(self):
        # ваш код
        return None # если стек пустой

    def push(self, value):
        # ваш код

    def peek(self):
        # ваш код
        return None # если стек пустой
```

В файле [stack.py](./stack.py) находится реализация стека на основе однонаправленного связного списка с фиктивным узлом в "голове" списка.

В файле [test_stack.py](./test_stack.py) находятся юнит-тесты для проверки корректности работы стека при добавлении/удалении элементов.

С использованием двух стеков реализован калькулятор постфиксных выражений ([postfix_expression.py](./postfix_expression.py)).

[Постфиксная запись выражения](https://habr.com/ru/articles/596925/) -- это запись, в которой порядок вычислений определяется не скобками и приоритетами, а только позицией элемента в выражении. Например, в выражениях разрешено использовать целые числа и операции + и * . Тогда выражение

(1 + 2) * 3

запишется как

1 2 + 3 * (верхушка стека слева)

Такой стек обрабатывается следующим образом: берём с верхушки объект, если это число, сохраняем во втором стеке, а если операция, выполняем её над двумя верхними элементами второго стека и возвращаем её обратно во второй стек.

Также с использованием стека [реализована](./brackets_balance.py) функция, которая получает на вход строку, состоящую из открывающих и закрывающих скобок (например, "(()((())()))" или "(()()(()") и, используя только стек и оператор цикла, определяет сбалансированы ли скобки в этой строке.

Сбалансированной считается последовательность, в которой каждой открывающей обязательно соответствует закрывающая, а каждой закрывающей -- открывающая скобки, то есть последовательности "())(" , "))((" или "((())" будут несбалансированы.